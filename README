liboil
======

A C library for resizing images. It currently does all resizing with a
catmull-rom interpolator. This library aims for fast performance, low memory
use, and accuracy.

Usage
-----

liboil provides separate methods for x-scaling and y-scaling. x-scaling is
relatively straightforward since it translates one input scanline to one output
scanline:

    void xscale(*in, in_width, *out, out_width, cmp, opts);

y-scaling works by translating multiple input scanlines to one output scanline.
The number of input scanlines depends on the input and output sizes.

The high-level yscaler API manages input scanlines for you:

    struct yscaler ys;
    int opts;
    uint32_t i, height_in, height_out, scanline_len;
    uint8_t *tmp, *scaled_scanline;

    // set height_in, height_out, width (in samples), cmp (components), opts
    // and scanline_len.
    scaled_scanline = malloc(scanline_len);

    yscaler_init(&ys, height_in, height_out, scanline_len);
    for (i=0; i<height_out; i++) {
        while ((tmp = yscaler_next(&ys))) {
          // populate tmp buffer with the next input scanline
        }
        yscaler_scale(&ys, scaled_scanline, width, cmp, opts, i);
        // handle output in scaled_scanline
    }
    yscaler_free(&ys);
    free(scaled_scanline);

Beneath the hood, yscaler uses sl_rbuf, a circular buffer for managing
scanlines. For fine-grained control, you can do the same:

    struct sl_rbuf rb;
    int opts;
    uint32_t i, height_in, height_out, scanline_len, taps;
    long target;
    float ty;
    uint8_t *tmp, *scaled_scanline, **virt;

    // set height_in, height_out, width (in samples), cmp (components), opts
    // and scanline_len.
    scaled_scanline = malloc(scanline_len);
    taps = calc_taps(height_in, height_out);

    sl_rbuf_init(&rb, taps, scanline_len);
    for (i=0; i<height_out; i++) {
        target = split_map(height_in, height_out, i, &ty) + taps / 2;
        while (rb.count <= target && rb.count < height_in) {
            tmp = sl_rbuf_next(&rb);
            // populate tmp buffer with the next input scanline
        }
        virt = sl_rbuf_virt(&rb, target);
        strip_scale((void **)virt, taps, width, scaled_scanline, ty, cmp, opts);
        // handle output in scaled_scanline
    }
    sl_rbuf_free(&rb);
    free(scaled_scanline);

It is also possible to manage scanlines yourself, performing y-scaling using
only the low-level primitives calc_taps(), split_map(), and strip_scale():

    int opts;
    uint32_t i, j, height_in, height_out, scanline_len, taps, rb_count, safe;
    long target;
    float ty;
    uint8_t *rbuf, *tmp, *scaled_scanline, **virt;

    // set height_in, height_out, width (in samples), cmp (components), opts
    // and scanline_len.
    scaled_scanline = malloc(scanline_len);
    taps = calc_taps(height_in, height_out);

    rbuf = malloc(scanline_len * taps);
    rb_count = 0;
    virt = malloc(sizeof(uint8_t *) * taps);

    for (i=0; i<height_out; i++) {
        target = split_map(height_in, height_out, i, &ty) + taps / 2;
        while (rb_count <= target && rb_count < height_in) {
            tmp = rbuf + (rb_count++ % taps) * scanline_len;
            // populate tmp buffer with the next input scanline
        }
        for (j=0; j<taps; j++) {
            safe = target < j ? 0 : target - j;
            safe = safe > height_in ? height_in : safe;
            virt[taps - j - 1] = rbuf + (safe % taps) * scanline_len;
        }
        strip_scale((void **)virt, taps, width, scaled_scanline, ty, cmp, opts);
        // handle output in scaled_scanline
    }
    free(virt);
    free(rbuf);
    free(scaled_scanline);

Testing
-------

Oil includes a test binary that compares the output of the resizer to a
reference implementation. You can build it with:

    $ make test

And run it with:

    $ ./test

It is recommended to run it with valgrind as well:

    $ valgrind ./test
